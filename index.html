<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Kira Smart Assistant ‚Äì Color Only</title>

<style>
/* ================== GLOBAL ================== */
body{
  margin:0;
  font-family:system-ui, -apple-system, BlinkMacSystemFont, sans-serif;
  background:linear-gradient(180deg,#050b1f,#0b1535);
  color:#e8ecff;
}

.container{
  max-width:420px;
  margin:20px auto;
  padding:16px;
}

/* ================== CARDS ================== */
.card{
  background:#0e1a3a;
  border:1px solid #1f3b8f;
  border-radius:14px;
  padding:14px;
  margin-bottom:14px;
  box-shadow:0 6px 18px rgba(0,0,0,.25);
}

h1{
  margin:0 0 6px;
  font-size:20px;
}

.small{
  opacity:.75;
  font-size:13px;
}

.center{
  text-align:center;
}

/* ================== COLORS ================== */
.green{color:#2ecc71}
.red{color:#ff4d4d}
.violet{color:#c77dff}
.wait{color:#f1c40f}

/* ================== BUTTONS ================== */
button{
  background:#142b6f;
  border:1px solid #2f55d4;
  color:#fff;
  padding:10px 14px;
  border-radius:10px;
  cursor:pointer;
  transition:all .2s ease;
}

button:hover{
  transform:translateY(-1px);
  box-shadow:0 4px 10px rgba(47,85,212,.4);
}

button.danger{
  background:#5a1a1a;
  border-color:#ff4d4d;
}

.flex{
  display:flex;
  gap:10px;
  justify-content:center;
}

/* ================== SYSTEM FOOTER ================== */
.system-footer{
  margin-top:16px;
  opacity:0.95;
}

/* STATUS TEXT */
.footer-status{
  font-size:13px;
  font-weight:500;
  margin-bottom:8px;
  transition:color .3s ease, text-shadow .3s ease;
}

/* ================== FOOTER COLOR STATES ================== */
.footer-green{
  color:#2ecc71;
  text-shadow:
    0 0 6px rgba(46,204,113,.45),
    0 0 12px rgba(46,204,113,.25);
}

.footer-red{
  color:#ff4d4d;
  text-shadow:
    0 0 6px rgba(255,77,77,.45),
    0 0 12px rgba(255,77,77,.25);
}

.footer-violet{
  color:#c77dff;
  text-shadow:
    0 0 6px rgba(199,125,255,.5),
    0 0 14px rgba(199,125,255,.35);
}

.footer-wait{
  color:#f1c40f;
  text-shadow:0 0 6px rgba(241,196,15,.35);
  animation:pulseGlow 2s infinite;
}

/* ================== CONFIDENCE BAR ================== */
.confidence-bar{
  width:100%;
  height:6px;
  background:#1a2555;
  border-radius:6px;
  overflow:hidden;
  margin-bottom:6px;
  position:relative;
}

#confidenceFill{
  height:100%;
  width:0%;
  background:#2ecc71;
  transition:width .4s ease, background .4s ease;
  position:relative;
}

/* subtle scanner shimmer */
#confidenceFill::after{
  content:"";
  position:absolute;
  inset:0;
  opacity:.18;
  background:linear-gradient(
    90deg,
    transparent,
    rgba(255,255,255,.45),
    transparent
  );
  animation:scan 2.5s linear infinite;
}

/* ================== WARNING TEXT ================== */
.footer-warning{
  font-size:11px;
  opacity:.55;
}

.footer-regard{
  font-size:11px;
  opacity:.55;
}

/* ================== ANIMATIONS ================== */
@keyframes pulseGlow{
  0%{text-shadow:0 0 4px transparent}
  50%{text-shadow:0 0 14px currentColor}
  100%{text-shadow:0 0 4px transparent}
}

.footer-pulse{
  animation:pulseGlow 1.4s infinite;
}

@keyframes scan{
  0%{transform:translateX(-100%)}
  100%{transform:translateX(100%)}
}
</style>
</head>

<body>
<div class="container">

<h1>ü§ñ Kira Predictor 3/4 level |</h1>
<div class="small">üÜî Dm For Access = @wtf.hrs</div>

<div class="card">
üü¢ <b>Status:</b> LIVE<br>
‚è± <span id="timer">--</span> seconds remaining
</div>

<div class="card" id="predictionBox">Loading‚Ä¶</div>

<div class="card" id="resultBox">Waiting for result‚Ä¶</div>

<div class="card" id="statsBox">
üìä Wins: 0 | ‚ùå Losses: 0 | üéØ Accuracy: 0%
</div>

<div class="flex">
  <button onclick="resetStats()">üìä Reset Stats</button>
  <button class="danger" onclick="resetHardStop()">üõë Reset Hard Stop</button>
</div>

<div class="card">
üìú <b>Lastest Results</b>
<div id="history"></div>
</div>

<div class="small center system-footer">
  <div id="footerStatus" class="footer-status">
    üß† Initializing engine‚Ä¶
  </div>
  <div class="footer-warning">
    ‚ö†Ô∏è No guarantees ‚Ä¢ Avoid over-betting ‚Ä¢ Stay disciplined ‚ö†Ô∏è
  </div>
    <div class="footer-regard">
   ‚úä 2026 ‚Ä¢ All Right ‚Ä¢ Reserved üí¶
  </div>
</div>


</div>

<script>
const API =
"https://draw.ar-lottery01.com/WinGo/WinGo_1M/GetHistoryIssuePage.json?pageNo=1&pageSize=10";

const history = document.getElementById("history");

/* ================= STATE ================= */
let state = JSON.parse(localStorage.getItem("dmwin_color_state")) || {
  wins:0,
  losses:0,
  lossStreak:0,
  cooldownRounds: 0,
  hardStop:false,
  lockedIssue:null,
  lockedPrediction:null,
  evaluatedIssue:null,
  biasGreen: 0,
  biasRed: 0,
  lastConfidence:null,
  lastOutcome:null,
  lastCheckedIssue: null,
  confirmingIssue: null,
  violetRisk:false
};

function save(){
  localStorage.setItem("dmwin_color_state",JSON.stringify(state));
}

/* ================= HELPERS ================= */
function colorOf(n){
  n = Number(n);
  if(n === 0) return "red,violet";
  if(n === 5) return "green,violet";
  return n % 2 === 0 ? "red" : "green";
}

function nextIssue(issue){
  const base = issue.slice(0,-2);
  const num  = Number(issue.slice(-2)) + 1;
  return base + String(num).padStart(2,"0");
}

/* ================= AI CORE ================= */
function analyze(list){

  /* ===== HARD STOP ===== */
  if(state.hardStop){
    return {action:"WAIT", reason:"Hard stop active"};
  }
  
  /* ===== COOLDOWN SHIELD ===== */
if(state.cooldownRounds > 0){
  state.cooldownRounds--;
  save();
  return {action:"WAIT", reason:"Cooldown after losses"};
}

  const last6 = list.slice(0,6);

  let green=0, red=0, violet=0;

  last6.forEach(i=>{
    const c = colorOf(i.number);
    if(c.includes("green")) green++;
    if(c.includes("red")) red++;
    if(c.includes("violet")) violet++;
  });

  /* ===== VIOLET RISK ===== */
  if(violet >= 2){
    state.violetRisk = true;
    save();
    return {action:"WAIT", reason:"High violet risk"};
  }
  state.violetRisk = false;


  /* ===== REPEAT TRAP FILTER ===== */
  const last3 = list.slice(0,3).map(i=>colorOf(i.number));
  const allSame3 = last3.every(c => c === last3[0]);
  if(allSame3){
    return {action:"WAIT", reason:"Repeat trap risk"};
  }

  /* ===== BIAS ADJUST ===== */
  const adjGreen = green + (state.biasGreen || 0) * 0.3;
  const adjRed   = red   + (state.biasRed   || 0) * 0.3;

  const edge = Math.abs(adjGreen - adjRed);

  /* ===== ADAPTIVE EDGE AFTER LOSS ===== */
  const minEdge = state.lossStreak === 1 ? 2.2 : 1.0;

  if(edge <= minEdge){
    return {action:"WAIT", reason:"No clear edge"};
  }

  /* ===== TOO MIXED PATTERN ===== */
  if(green >= 3 && red >= 3){
    return {action:"WAIT", reason:"Mixed pattern"};
  }

  /* ===== PICK ===== */
  const pick = adjGreen > adjRed ? "GREEN" : "RED";

  /* ===== CONFIDENCE (OLD STYLE + SMART BONUS) ===== */
  let confidence = Math.round((Math.max(green, red)/6)*100);

  if(edge >= 3) confidence += 8;

  /* decay after losses */
  confidence -= state.lossStreak * 8;

  if(confidence > 92) confidence = 92;
  if(confidence < 42) confidence = 42;

  return {action:pick, confidence};
}

/* ================= MAIN LOOP ================= */
async function tick(){
  let list;
try {
  const res = await fetch(API);
  const json = await res.json();
  list = json.data.list;
} catch(e){
  console.log("API error", e);
  return; // skip this tick safely
}

await new Promise(r => setTimeout(r, 1200));

  const completedIssue = list[0].issueNumber;
  const bettingIssue   = nextIssue(completedIssue);
  const latestColors   = colorOf(list[0].number);

  /* === PRO SYNC RESULT CHECK === */
if(state.lockedIssue === completedIssue){

  // safety
  if(!state.lockedPrediction) return;

  // first time see ‚Äî mark
  if(state.confirmingIssue !== completedIssue){
    state.confirmingIssue = completedIssue;
    save();
  }

  // second tick ‚Äî confirm result
  else if(state.evaluatedIssue !== completedIssue){

    if(latestColors.includes(state.lockedPrediction)){
      state.wins++;
      state.lossStreak = 0;
      state.cooldownRounds = 0;

      if(state.lockedPrediction === "green") state.biasGreen += 1;
      if(state.lockedPrediction === "red")   state.biasRed   += 1;

      resultBox.innerHTML =
        "‚úÖ Last Bet: <span class='green'>WIN</span>";
      state.lastOutcome = "WIN";

    } else {

      state.losses++;
      state.lossStreak++;

      if(state.lossStreak === 3){
        state.cooldownRounds = 2;
      }

      if(state.lossStreak >= 5){
        state.hardStop = true;
      }

      if(state.lockedPrediction === "green") state.biasGreen -= 0.5;
      if(state.lockedPrediction === "red")   state.biasRed   -= 0.5;

      resultBox.innerHTML =
        "‚ùå Last Bet: <span class='red'>LOSS</span>";
      state.lastOutcome = "LOSS";
    }

    state.evaluatedIssue = completedIssue;
    state.confirmingIssue = null;
    save();
  }
}

  /* === PREDICTION LOCK === */
  if(state.lockedIssue !== bettingIssue){
    const d = analyze(list);

    if(d.action === "WAIT"){

  // üî• FORCE UNLOCK ‚Äî IMPORTANT
  state.lockedIssue = null;
  state.lockedPrediction = null;

  predictionBox.innerHTML =
    "‚è∏ <b>Prediction:</b> <span class='wait'>WAIT</span><br>" +
    "<span class='small'>" + d.reason + "</span>";

  state.lastWaitReason = d.reason;
  save();
}else{
      state.lockedIssue = bettingIssue;
      state.lockedPrediction = d.action.toLowerCase();
      save();

      predictionBox.innerHTML =
        "üéØ <b>Prediction:</b> <span class='" + d.action.toLowerCase() + "'>" +
        d.action + "</span><br>" +
        "<span class='small'>Locked for period " + bettingIssue +
        " ‚Ä¢ Confidence: " + d.confidence + "%</span>";
    }
  }else{
    predictionBox.innerHTML =
      "üîí <b>Prediction:</b> <span class='" + state.lockedPrediction + "'>" +
      state.lockedPrediction.toUpperCase() + "</span><br>" +
      "<span class='small'>Locked for period " + state.lockedIssue + "</span>";
  }

  /* === STATS === */
  const total = state.wins + state.losses;
  const acc   = total ? Math.round((state.wins / total) * 100) : 0;
  statsBox.innerText =
    `üìä Wins: ${state.wins} | ‚ùå Losses: ${state.losses} | üéØ Accuracy: ${acc}%`;

  /* === LATEST RESULTS (COMPLETED ONLY) === */
  history.innerHTML = list.slice(0,5).map(i=>{
    const parts = colorOf(i.number).split(",");
    const html = parts.map(p=>`<span class="${p}">${p}</span>`).join(" + ");
    return `<div>${i.issueNumber} ‚Üí ${html}</div>`;
  }).join("");
}

/* ================= TIMER ================= */
setInterval(()=>{
  const s = new Date().getSeconds();
  const remain = s === 0 ? 60 : 60 - s;
  const el = document.getElementById("timer");
  if(el) el.innerText = remain;
},500);

/* ================= CONTROLS ================= */
function resetStats(){
  state.wins = 0;
  state.losses = 0;
  state.lossStreak = 0;
  state.lockedIssue = null;
  state.lockedPrediction = null;
  state.evaluatedIssue = null;
  save();
  location.reload();
}

function resetHardStop(){
  state.lossStreak = 0;
  state.hardStop = false;
  save();
  alert("Hard stop reset");
}

/* ================= START ================= */
function startSyncedLoop(){
  tick(); // run immediately once

  const now = new Date();
  const delay = (60 - now.getSeconds()) * 1000;

  setTimeout(()=>{
    tick(); // run exactly at next minute boundary
    setInterval(tick, 5000); // then perfectly aligned
  }, delay);
}

startSyncedLoop();
/* ===== CLEAR RESULT MESSAGE AFTER DISPLAY ===== */
setInterval(() => {
  if (state.lastOutcome) {
    state.lastOutcome = null;
    resultBox.innerHTML = "Waiting for result‚Ä¶";
    save();
  }
}, 5000);
/* ===== SMART FOOTER STATUS ENGINE v3 (WITH VIOLET ZONE) ===== */
let footerTick = 0;

function getFooterMessages(){

  /* üõë HARD STOP */
  if (state.hardStop) {
    return [
      "üõë HARD STOP active",
      "üßä Capital protection enabled",
      "üîÑ Manual reset required",
      "üóø Owner - HARSH"
    ];
  }

  /* üü£ VIOLET ZONE */
  if (state.violetRisk) {
    return [
      "üü£ Violet Zone detected",
      "‚ö†Ô∏è High variance outcomes",
      "üß† AI avoiding unstable patterns",
      "‚è∏ Trade skipped to protect capital",
      "üóø Owner - HARSH"
    ];
  }

  /* üî• OVERHEATED STREAK */
  if (state.lastWaitReason === "Overheated streak") {
    return [
      "üî• Overheated streak detected",
      "üß† AI cooling system active",
      "‚è∏ Skipping trap entry",
      "üóø Owner - HARSH"
    ];
  }

  /* ‚öñÔ∏è MIXED PATTERN */
  if (state.lastWaitReason === "Mixed pattern") {
    return [
      "‚öñÔ∏è Mixed pattern detected",
      "üìä No dominance found",
      "‚è∏ Waiting for clarity",
      "üóø Owner - HARSH"
    ];
  }

  /* ‚ùì NO EDGE */
  if (state.lastWaitReason === "No clear edge") {
    return [
      "‚ùì No statistical edge",
      "üìâ Signal too weak",
      "‚è∏ Trade avoided",
      "üóø Owner - HARSH"
    ];
  }

  /* ü™§ REPEAT TRAP */
  if (state.lastWaitReason === "Repeat trap risk") {
    return [
      "ü™§ Repeat trap risk",
      "üìõ Streak reversal zone",
      "‚è∏ Entry blocked",
      "üóø Owner - HARSH"
    ];
  }

  /* ‚úÖ WIN */
  if (state.lastOutcome === "WIN") {
    return [
      "‚úÖ WIN registered",
      "üìà Bias strengthened",
      "üß† Model reinforced",
      "üóø Owner - HARSH"
    ];
  }

  /* ‚ùå LOSS */
  if (state.lastOutcome === "LOSS") {
    return [
      "‚ùå LOSS registered",
      "üß† Bias adjusted",
      "üßä Risk tightening",
      "üóø Owner - HARSH"
    ];
  }

  /* ‚è∏ WAIT MODE */
  if (!state.lockedPrediction) {
    return [
      "‚è∏ No trade locked",
      "üß† AI scanning",
      "üìä Confidence too low",
      "üóø Owner - HARSH"
    ];
  }

  /* üîí LOCKED MODE */
  return [
    `üîí Locked ${state.lockedPrediction.toUpperCase()} ‚Ä¢ ${state.lockedIssue}`,
    "üì° Monitoring round",
    "üß† AI holding position",
    "üí∏ Bet Now",
    "üóø Owner - HARSH"
  ];
}


setInterval(() => {
  const el = document.getElementById("footerStatus");
  if (!el) return;

  const msgs = getFooterMessages();
  const msg  = msgs[footerTick % msgs.length];
  footerTick++;

  // reset classes
  el.className = "footer-status";

  // color priority order
if (state.hardStop) {
  el.classList.add("footer-red");
}
else if (state.violetRisk) {
  el.classList.add("footer-violet");
}
else if (state.lockedPrediction === "green") {
  el.classList.add("footer-green");
}
else if (state.lockedPrediction === "red") {
  el.classList.add("footer-red");
}
else {
  el.classList.add("footer-wait");
}

  el.innerText = msg;
}, 1300);
</script>

</body>
</html>
